---
description: Testing guidelines and best practices for unit tests and E2E tests
globs: **/*.test.ts, **/*.test.tsx, **/*.spec.ts, **/*.spec.tsx, **/vitest.config.ts, **/tests/**, test-setup/**/*
---
# Testing Rules

## Testing Commands

**CRITICAL**: Always use `bun run test` instead of `bun test` for unit tests.

### Unit Tests (Vitest 4.0 Projects API)

#### Workspace Mode (All Projects)
Run all 6 test projects (wallet, listener, business, wallet-shared, core-sdk, react-sdk) in parallel:
```bash
bun run test                  # Run all 179 test files (1927 tests) across all projects
bun run test:ui               # Run with Vitest UI for all projects
bun run test:coverage         # Run with coverage report for all projects
bun run test --project wallet-unit  # Run specific project only
```

#### Individual Projects
Run tests for a specific project:

**Wallet App**
```bash
cd apps/wallet
bun run test                  # Run wallet unit tests only
bun run test:ui               # Run with Vitest UI
bun run test:coverage         # Run with coverage report
```

**Listener App**
```bash
cd apps/listener
bun run test                  # Run listener unit tests only
bun run test:ui               # Run with Vitest UI
bun run test:coverage         # Run with coverage report
```

**Business App**
```bash
cd apps/business
bun run test                  # Run business unit tests only
bun run test:ui               # Run with Vitest UI
bun run test:coverage         # Run with coverage report
```

### E2E Tests (Playwright)

#### Wallet App
```bash
cd apps/wallet
bun run test:e2e              # Run tests against local
bun run test:e2e:dev          # Run tests against dev environment
bun run test:e2e:prod         # Run tests against prod environment
bun run test:e2e:ui           # Run with Playwright UI
```

## Test Framework

- **Unit Tests**: Vitest 4.0 with Projects API (workspace mode) and jsdom environment
  - 7 test projects: wallet-unit, listener-unit, business-unit, wallet-shared-unit, ui-unit, core-sdk-unit, react-sdk-unit
  - Test files across all projects (includes component tests)
  - Parallel execution across all projects from root directory
- **Coverage**: v8 provider with 40% threshold (lines, functions, branches, statements)
- **E2E Tests**: Playwright for end-to-end testing
- **Testing Library**: @testing-library/react for React hooks and components

## Test Configuration Architecture

### Workspace Configuration (Vitest 4.0 Projects API)
- **`vitest.config.ts`** (root) - Workspace entry point, discovers all project configs
- **`test-setup/vitest.shared.ts`** - Shared configuration inherited by all projects:
  - Common settings: environment: "jsdom", timeouts, reporters, coverage thresholds
  - Individual projects extend with `mergeConfig(sharedConfig, defineConfig({...}))`

### Shared Test Setup Files
Located in `test-setup/` directory:

- **`vitest.shared.ts`** - Shared configuration and plugin helpers:
  - Common Vitest settings (jsdom, timeouts, reporters, coverage)
  - `getReactTestPlugins()` - React + TypeScript path mapping plugins
  - `getReactOnlyPlugins()` - React plugin only (for packages without path aliases)

- **`shared-setup.ts`** - Browser API mocks for all projects:
  - `crypto.randomUUID` polyfill
  - `window.matchMedia` mock
  - `IntersectionObserver` mock
  - `ResizeObserver` mock
  - `MessageChannel` mock (for iframe communication)

- **`react-setup.ts`** - React-specific setup:
  - BigInt serialization for Zustand persist middleware

- **`router-mocks.ts`** - Router mock factory functions:
  - `setupReactRouterMock()` - For react-router (wallet, wallet-shared)
  - `setupTanStackRouterMock()` - For @tanstack/react-router (business)
  - Factory functions for creating custom router mocks

- **`dom-mocks.ts`** - DOM mocking utilities:
  - `mockWindowOrigin()` - Mock window.origin property
  - `mockDocumentReferrer()` - Mock document.referrer property
  - `setupListenerDomMocks()` - Combined setup for listener app

- **`wallet-mocks.ts`** - Wallet-specific mocks (wallet + wallet-shared):
  - Wagmi hooks (useAccount, useConnect, useBalance, etc.)
  - WebAuthn API (ox library)
  - IndexedDB (idb-keyval)
  - Uses `router-mocks.ts` for React Router mocking

- **`apps-setup.ts`** - Frontend app-specific setup:
  - Environment variables (STAGE, BACKEND_URL, etc.)
  - OpenPanel analytics mock
  - document.cookie mock

- **`README.md`** - Comprehensive test architecture documentation:
  - Setup file execution order and dependencies
  - Fixture inheritance chain
  - When to use fixtures vs factories
  - Project-specific setup details
  - Common patterns and best practices
  - Debugging guide

### Project-Specific Setup Files
Each project has its own setup file importing shared configurations:
- `apps/wallet/tests/vitest-setup.ts`
- `apps/listener/tests/vitest-setup.ts`
- `apps/business/tests/vitest-setup.ts`
- `packages/wallet-shared/tests/vitest-setup.ts`
- `packages/ui/tests/vitest-setup.ts`
- `sdk/core/tests/vitest-setup.ts`
- `sdk/react/tests/vitest-setup.ts`

## Test Organization

### Unit Test Location
- Co-locate tests with source files (e.g., `modalStore.test.ts` next to `modalStore.ts`)
- Use `*.test.ts` or `*.test.tsx` extension
- Setup files located in `tests/vitest-setup.ts`
- Tests should be placed in the same directory as the code they test

### Test File Structure
```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";

describe("ComponentName", () => {
    beforeEach(() => {
        vi.clearAllMocks();
    });

    it("should do something specific", () => {
        // Arrange
        // Act
        // Assert
    });
});
```

## Mocking Strategies

### External Packages
Mock at module level with `vi.mock()`:
```typescript
vi.mock("@frak-labs/wallet-shared", () => ({
    get sessionStore() { return mockSessionStore; },
    getSafeSession: () => mockGetSafeSession(),
}));
```

### Zustand Stores
Create dual-purpose mocks (function + object with getState/subscribe):
```typescript
const mockSessionStore: any = Object.assign(
    vi.fn((selector: any) => {
        const state = { session: undefined };
        return selector(state);
    }),
    {
        getState: vi.fn(() => ({ session: undefined })),
        subscribe: vi.fn(() => vi.fn()),
    }
);
```

### Hoisting Issues
Use getter properties in `vi.mock()` to avoid hoisting issues:
```typescript
vi.mock("module", () => ({
    get value() { return mockValue; },  // Lazy evaluation
}));
```

### Common Mocks
- **Wagmi**: Mock hooks like `useAccount`, `usePublicClient`, `useWalletClient`
- **TanStack Query**: Mock `useQuery`, `useMutation`, `useQueryClient`
- **WebAuthn**: Mock `@simplewebauthn/browser` functions
- **react-i18next**: Mock `useTranslation`, `getI18n`

## Test Setup Utilities

### Plugin Helpers (vitest.shared.ts)

Use plugin helpers in vitest.config.ts to reduce boilerplate:

```typescript
// For React + TypeScript path mapping (wallet, listener, business)
import sharedConfig, { getReactTestPlugins } from "../../test-setup/vitest.shared";

export default mergeConfig(
    sharedConfig,
    defineConfig({
        plugins: await getReactTestPlugins(),
        // ... project config
    })
);

// For React-only (wallet-shared - no path aliases)
import sharedConfig, { getReactOnlyPlugins } from "../../test-setup/vitest.shared";

export default mergeConfig(
    sharedConfig,
    defineConfig({
        plugins: await getReactOnlyPlugins(),
        // ... project config
    })
);
```

### Router Mock Utilities (router-mocks.ts)

Use router mock factories in project setup files:

```typescript
// For react-router (wallet, wallet-shared)
import { setupReactRouterMock } from "../../../test-setup/router-mocks";
await setupReactRouterMock();

// For @tanstack/react-router (business)
import { setupTanStackRouterMock } from "../../../test-setup/router-mocks";
await setupTanStackRouterMock();

// With custom state
await setupReactRouterMock({
    pathname: "/custom",
    search: "?foo=bar"
});
```

### DOM Mock Utilities (dom-mocks.ts)

Use DOM mocking utilities for window/document properties:

```typescript
import {
    mockWindowOrigin,
    mockDocumentReferrer,
    setupListenerDomMocks
} from "../../../test-setup/dom-mocks";

// Individual mocks
mockWindowOrigin("https://example.com");
mockDocumentReferrer("https://referrer.com");

// Combined setup (for listener)
setupListenerDomMocks({
    origin: "https://example.com",
    referrer: "https://referrer.com"
});
```

## Testing React Hooks

### Using renderHook
```typescript
import { renderHook, waitFor } from "@testing-library/react";

it("should update state", async () => {
    const { result } = renderHook(() => useMyHook());

    await waitFor(() => {
        expect(result.current.value).toBe(expectedValue);
    });
});
```

### Async Handlers
```typescript
it("should handle async operation", async () => {
    const { result } = renderHook(() => useAsyncHook());

    const promise = result.current.handler(params);

    await waitFor(() => {
        expect(mockFunction).toHaveBeenCalled();
    });

    await promise;
});
```

## Testing React Components

### When to Write Component Tests

Component tests are valuable for:
- **UI Components** (`packages/ui/component/`) - Core reusable components
- **Wallet-Shared Components** (`packages/wallet-shared/src/*/component/`) - Domain-specific UI components
- **Complex Components** - Components with multiple states, interactions, or edge cases
- **Critical User Flows** - Components that handle important user interactions

Component tests supplement E2E tests by providing faster feedback during development and catching regressions early.

### Component Test Structure

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { Button } from "./index";

describe("Button", () => {
    beforeEach(() => {
        vi.clearAllMocks();
    });

    it("should render with default props", () => {
        render(<Button>Click me</Button>);
        expect(screen.getByRole("button", { name: "Click me" })).toBeInTheDocument();
    });

    it("should handle click events", () => {
        const handleClick = vi.fn();
        render(<Button onClick={handleClick}>Click me</Button>);

        fireEvent.click(screen.getByRole("button"));
        expect(handleClick).toHaveBeenCalledTimes(1);
    });
});
```

### What to Test in Components

**DO Test:**
- Component renders correctly with default props
- Props are applied correctly (variants, sizes, states)
- User interactions (clicks, input changes, form submissions)
- Edge cases (empty states, disabled states, error states)
- Accessibility (ARIA attributes, keyboard navigation, focus management)
- Controlled vs uncontrolled behavior
- Callback functions are called with correct arguments

**DON'T Test:**
- Implementation details (internal state, CSS class names)
- Third-party library behavior (Radix UI internals, vaul internals)
- Styling details (colors, spacing, layout - use E2E for visual testing)
- Component composition details (how subcomponents are structured)

### Testing Radix UI Components

Radix UI components use portals and complex state management. Testing patterns:

**Use accessible queries:**
```typescript
// ✅ DO: Use role-based queries
screen.getByRole("button", { name: "Open Dialog" });
screen.getByRole("alertdialog");
screen.getByRole("switch");

// ❌ DON'T: Query by CSS classes or implementation details
container.querySelector(".alertDialog__content");
```

**Test portal rendering:**
```typescript
// For modals, dialogs, drawers - content renders in portal
await waitFor(() => {
    expect(screen.getByRole("alertdialog")).toBeInTheDocument();
});
```

**Test controlled/uncontrolled modes:**
```typescript
// Controlled mode
const { rerender } = render(<Dialog open={false} />);
expect(screen.queryByRole("dialog")).not.toBeInTheDocument();

rerender(<Dialog open={true} />);
await waitFor(() => {
    expect(screen.getByRole("dialog")).toBeInTheDocument();
});

// Uncontrolled mode
render(<Dialog defaultOpen={true} />);
await waitFor(() => {
    expect(screen.getByRole("dialog")).toBeInTheDocument();
});
```

### Testing CSS Modules

CSS Modules generate hashed class names, so don't test specific class names:

```typescript
// ❌ DON'T: Test specific class names
expect(container.firstChild).toHaveClass("button_primary_abc123");

// ✅ DO: Test behavior and visual state
expect(button).toBeDisabled();
expect(button).toHaveAttribute("type", "submit");
expect(screen.getByRole("button")).toBeInTheDocument();
```

### Testing Wallet-Shared Components

Wallet-shared components may depend on:
- **React Query** - Mock `@tanstack/react-query` hooks if needed
- **i18n** - Mock `react-i18next` if components use `useTranslation`
- **Wagmi** - Mock Wagmi hooks if components use blockchain functionality
- **Router** - Router mocks are already set up in `wallet-mocks.ts`

Example with mocks:
```typescript
import { vi } from "vitest";

// Mock React Query if component uses it
vi.mock("@tanstack/react-query", () => ({
    useQuery: vi.fn(() => ({ data: null, isLoading: false })),
}));

// Component test
it("should render with data", () => {
    render(<ComponentThatUsesQuery />);
    // ... test assertions
});
```

### Component Test Examples

**Button Component:**
```typescript
describe("Button", () => {
    it("should render all variants", () => {
        const variants = ["primary", "secondary", "outline"] as const;
        variants.forEach((variant) => {
            const { unmount } = render(<Button variant={variant}>Button</Button>);
            expect(screen.getByRole("button")).toBeInTheDocument();
            unmount();
        });
    });

    it("should show loading state", () => {
        render(<Button isLoading>Loading</Button>);
        expect(screen.getByRole("button")).toBeDisabled();
    });
});
```

**Input Component:**
```typescript
describe("Input", () => {
    it("should handle onChange events", () => {
        const handleChange = vi.fn();
        render(<Input onChange={handleChange} />);

        const input = screen.getByRole("textbox");
        fireEvent.change(input, { target: { value: "new value" } });

        expect(handleChange).toHaveBeenCalledTimes(1);
    });

    it("should render with leftSection and rightSection", () => {
        render(<Input leftSection="@" rightSection="✓" />);
        expect(screen.getByText("@")).toBeInTheDocument();
        expect(screen.getByText("✓")).toBeInTheDocument();
    });
});
```

**Modal/Dialog Component:**
```typescript
describe("AlertDialog", () => {
    it("should open when trigger is clicked", async () => {
        render(
            <AlertDialog
                title="Test"
                button={{ label: "Open" }}
            />
        );

        fireEvent.click(screen.getByRole("button", { name: "Open" }));

        await waitFor(() => {
            expect(screen.getByRole("alertdialog")).toBeInTheDocument();
        });
    });

    it("should close when overlay is clicked", async () => {
        const handleOpenChange = vi.fn();
        render(
            <AlertDialog
                title="Test"
                button={{ label: "Open" }}
                onOpenChange={handleOpenChange}
            />
        );

        fireEvent.click(screen.getByRole("button", { name: "Open" }));
        await waitFor(() => {
            expect(screen.getByRole("alertdialog")).toBeInTheDocument();
        });

        // Click overlay
        const overlay = document.querySelector('[data-radix-portal]');
        if (overlay) {
            fireEvent.click(overlay);
            await waitFor(() => {
                expect(handleOpenChange).toHaveBeenCalledWith(false);
            });
        }
    });
});
```

### UI Package Testing

The UI package (`packages/ui/`) has its own Vitest configuration:
- **Config**: `packages/ui/vitest.config.ts`
- **Setup**: `packages/ui/tests/vitest-setup.ts`
- **Test scripts**: `bun run test`, `bun run test:ui`, `bun run test:coverage`

Run UI package tests:
```bash
cd packages/ui
bun run test              # Run tests
bun run test:ui           # Run with Vitest UI
bun run test:coverage     # Run with coverage
```

UI package tests are included when running `bun run test` from root.

## Coverage Targets

### Required Coverage
- Lines: 40%
- Functions: 40%
- Branches: 40%
- Statements: 40%

### Coverage Exclusions
- UI components: `**/component/**/*.tsx`
- Entry points: `app/main.tsx`, `app/App.tsx`
- Build artifacts and node_modules
- Test files themselves

## Best Practices

### Test Independence
- Each test should be independent and not rely on other tests
- Use `beforeEach` to reset state between tests
- Clear all mocks with `vi.clearAllMocks()`

### Test Naming
- Use descriptive test names that explain what is being tested
- Format: "should [expected behavior] when [condition]"
- Example: "should emit connected status when wallet session exists"

### Test Coverage Focus
- Focus on business logic and state management
- Test error paths and edge cases
- Don't over-test implementation details
- Prioritize critical user flows

### Async Testing
- Always use `async/await` with `waitFor` for async operations
- Don't use arbitrary timeouts - let `waitFor` handle timing
- Test both success and error cases for async operations

### Mock Management
- Keep mocks close to the tests that use them
- Create reusable mock factories when needed
- Document complex mocking strategies
- Reset mocks between tests to avoid side effects

## Resource Tags

Use these tags to find relevant documentation:

- @Vitest - Vitest testing framework documentation
- @TestingLibrary - React Testing Library documentation
- @Playwright - Playwright E2E testing documentation
